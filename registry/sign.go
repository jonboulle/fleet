package registry

import (
	"path"

	"github.com/coreos/fleet/sign"
)

const (
	signingPrefix = "/signing/"
)

// CreateSignatureSet stores the given SignatureSet in the repository
func (r *Registry) CreateSignatureSet(ss *sign.SignatureSet) error {
	key := signatureSetPath(ss.Tag)
	json, _ := marshal(ss)
	_, err := r.etcd.Create(key, json, 0)
	return err
}

// DestroySignatureSet destroys the SignatureSet associated with the given tag
func (r *Registry) DestroySignatureSet(tag string) {
	key := signatureSetPath(tag)
	r.etcd.Delete(key, false)
}

// GetSignatureSet returns the SignatureSet associated with the given tag
func (r *Registry) GetSignatureSet(tag string) *sign.SignatureSet {
	key := signatureSetPath(tag)
	resp, err := r.etcd.Get(key, false, true)

	// Assume the error was KeyNotFound and return an empty data structure
	if err != nil {
		return nil
	}

	var sig sign.SignatureSet
	//TODO: Handle the error generated by unmarshal
	unmarshal(resp.Node.Value, &sig)

	return &sig
}

// GetSignatureSetOfJob retrieves the SignatureSet associated with the given
// job, or nil if none can be found
func (r *Registry) GetSignatureSetOfJob(name string) *sign.SignatureSet {
	return r.GetSignatureSet(sign.TagForJob(name))
}

func (r *Registry) destroySignatureSetOfJob(name string) {
	r.DestroySignatureSet(sign.TagForJob(name))
}

func (r *Registry) GetSignatureSetOfLegacyPayload(name string) *sign.SignatureSet {
	return r.GetSignatureSet(sign.TagForPayload(name))
}

func (r *Registry) destroySignatureSetOfLegacyPayload(name string) {
	r.DestroySignatureSet(sign.TagForPayload(name))
}

func signatureSetPath(s string) string {
	return path.Join(keyPrefix, signingPrefix, s)
}
